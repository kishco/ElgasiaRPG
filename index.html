<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Elgasia - Text RPG ver1.06</title>
  <style>
    body { font-family: 'Malgun Gothic', sans-serif; background: #232236; color: #fff; margin: 0; padding: 0;}
    #main { max-width: 900px; margin: 40px auto; background: #181828; padding: 30px; border-radius: 20px; box-shadow: 0 0 30px #0008;}
    .stat-box { margin: 12px 0 24px 0; }
    .stat-box span { display: inline-block; margin-right: 18px; font-size: 18px; }
    .btn-bar button { background: #384085; color: #fff; border: none; border-radius: 7px; margin: 4px; padding: 10px 20px; font-size: 17px; cursor: pointer; transition: background 0.15s;}
    .btn-bar button:disabled { background: #333; color: #aaa; cursor: not-allowed; }
    .equip-rare { color: #51cafc; } .equip-unique { color: #d76bff; }
    .equip-normal { color: #fff;}
.equip-epic {
  color: #ff90b5;
  font-weight: bold;
  text-shadow:
    0 0 8px #ff90b5,
    0 0 22px #f080c1,
    0 0 35px #ffe2f1;
  animation: epic-glow 1.5s infinite alternate;
}
@keyframes epic-glow {
  from { filter: brightness(1) drop-shadow(0 0 8px #ff90b5); }
  to   { filter: brightness(1.24) drop-shadow(0 0 14px #ff90b5) drop-shadow(0 0 25px #f080c1); }
}

.equip-legend {
  color: gold;
  font-weight: bold;
  text-shadow:
    0 0 12px #ffe161,
    0 0 32px #ffd966,
    0 0 44px #ffe161;
  animation: legend-glow 1.1s infinite alternate;
  letter-spacing: 1.1px;
}
@keyframes legend-glow {
  from { filter: brightness(1.08) drop-shadow(0 0 10px #ffe161); }
  to   { filter: brightness(1.33) drop-shadow(0 0 24px #ffd700) drop-shadow(0 0 32px #ffe161); }
}

.equip-myth {
  color: #b366ff;
  font-weight: bold;
  text-shadow:
    0 0 13px #d76bff,
    0 0 24px #a559f3,
    0 0 38px #b366ff;
  animation: myth-glow 1.4s infinite alternate;
  letter-spacing: 1.15px;
}
@keyframes myth-glow {
  from { filter: brightness(1.10) drop-shadow(0 0 11px #cdaaff); }
  to   { filter: brightness(1.38) drop-shadow(0 0 23px #b366ff) drop-shadow(0 0 27px #a559f3); }
}

.equip-inferno {
  color: #ff2424;
  font-weight: bold;
  font-size: 18px;
  letter-spacing: 1.4px;
  text-shadow:
    0 0 15px #fa2525,
    0 0 38px #ff2323,
    0 0 60px #ff3939,
    0 0 90px #ff6868;
  filter: brightness(1.28) drop-shadow(0 0 12px #ff6464);
  animation: doomglow 0.93s infinite alternate, inferno-blink 1.8s infinite alternate;
}
@keyframes doomglow {
  from { text-shadow: 0 0 26px #ff2323, 0 0 55px #ff6d6d; }
  to   { text-shadow: 0 0 45px #ff5656, 0 0 95px #ff2323; }
}
@keyframes inferno-blink {
  from { opacity: 0.96; }
  to   { opacity: 1; filter: brightness(1.39) drop-shadow(0 0 18px #ff2323); }
}
    .log { border: 1px solid #222; background: #191934; margin: 16px 0; border-radius: 10px; min-height: 120px; padding: 14px; font-size:17px;}
   .inv-btn {
  min-width: 74px;
  text-align: center;
  margin-right: 5px;
}
    .inv-btn:disabled { color: #888;}
.equipitem {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 14px;
  padding: 3px 0 2px 0;
  margin: 2px 0;
  border-bottom: 1px solid #29293f;
  white-space: nowrap;
}
.equipitem.combine2row {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  margin-bottom: 18px;
  border-bottom: 1px solid #29293f;
  padding-bottom: 7px;
  padding-top: 7px;
}
.combine-itembox {
  width: 100%;
  margin-bottom: 2px;
}
.combine-itembox:last-of-type {
  margin-bottom: 5px;
}
.combine-btnbox {
  width: 100%;
  display: flex;
  justify-content: flex-end;
  margin-top: 3px;
}
.item-btns {
  display: flex;
  gap: 6px;
  margin-left: 12px;
}
.equipitem .item-btns {
  display: flex;
  gap: 6px;
  margin-left: 12px;
}
.equip-bonus, .stat-label {
  color: #aaffb8;
  margin-left: 10px;
  font-size: 13px;
  font-weight: 400;
}

    .equip-bonus {font-size:14px;color:#b8ffad;}
    .namebox input { font-size:18px; padding:3px 8px; border-radius:7px; border:1px solid #555;}
    .save-bar button { background: #515b9d; color: #fff; border: none; border-radius: 6px; margin: 2px; padding: 7px 15px; font-size: 15px;}
    .save-slot-btn { background:#2e2e4e; color:#fff; margin:7px; padding:15px 30px; font-size:22px; border-radius:10px; border:none;}
    .shop-item { margin:8px 0; padding:12px; border-radius:10px; background: #21214a; box-shadow: 0 2px 8px #0003;}
    .shop-item .equip-bonus { color:#bbeeff; }
    .shop-title { color:#ffe680; font-size: 21px; margin-bottom:10px;}
    .enhance-btn { background: #1f8e26; color: #fff; margin-left:12px; border-radius:6px;}
    .fail-msg { color:#ff6161; font-weight:bold; }
    .succ-msg { color:#8aff8a; font-weight:bold; }
    .enh-lv {color: #ffe161; font-weight: bold; margin-left: 6px;}
    .monname { color:#ffd700; font-weight:bold;}
    .save-del-btn { background:#a23c3c; color:#fff; border-radius:7px; border:none; font-size:14px; padding:4px 14px; margin-left:8px;}
    .ilv-txt { color:#9ed1f7; font-weight:bold; margin-right:8px; }
    .skill-log { color:#ffea64; font-weight:bold; }
    .dmg-log { color:#fba; }
    .dead-log { color:#fa4247; font-weight:bold; }
    .unique-monster { color:#ff5555; font-weight:bold; }
     .set-bonus { color: #ffe161; font-weight: bold;}

  /* --- 여기부터 덧붙여라 --- */
 #mainwrap {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
}

#centerwrap {
  flex: 1.7;
  min-width: 480px;
  max-width: 900px;
  min-height: 300px;
  max-height: 700px;
  overflow-y: auto;
  background: #23223a;
  border-radius: 30px 0 0 30px;
  margin: 55px 0 55px 0;
  padding: 35px 40px 32px 45px;
  box-shadow: 0 4px 36px #10101965, 0 2px 18px #0008;
  display: flex;
  flex-direction: column;
}

#userinfo {
  margin-bottom: 24px;
  font-size: 18px;
  letter-spacing: 0.3px;
}

.log {
  border: 1.5px solid #2d2e43;
  background: #1c1c2f;
  border-radius: 18px;
  min-height: 110px;
  padding: 18px 22px;
  font-size: 17px;
  color: #f6f7ff;
  box-shadow: 0 1.5px 8px #0002;
  margin-bottom: 0;
  overflow-x: auto;
  word-break: break-all;
  white-space: pre-line;
}

#sidebar {
  flex: 0 0 240px;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  background: linear-gradient(140deg, #262655 70%, #353565 100%);
  border-radius: 0 30px 30px 0;
  margin: 55px 0 55px 0;
  padding: 40px 26px 34px 16px;
  min-height: 520px;
  min-width: 200px;
  box-shadow: 0 4px 36px #19193380;
}

.btn-bar, .save-bar {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  margin-bottom: 20px;
}

.btn-bar button, .save-bar button {
  width: 100%;
  margin-bottom: 14px;
  font-size: 18px;
  font-weight: 600;
  border-radius: 14px;
  background: linear-gradient(90deg, #4252be 70%, #6e89ec 100%);
  border: none;
  color: #fff;
  padding: 13px 0;
  letter-spacing: 1.2px;
  cursor: pointer;
  box-shadow: 0 2px 8px #233;
  transition: background 0.18s, transform 0.12s, box-shadow 0.18s;
}
.btn-bar button:disabled, .save-bar button:disabled {
  background: #333a;
  color: #aaa;
  cursor: not-allowed;
}

.btn-bar button:hover:not(:disabled), .save-bar button:hover:not(:disabled) {
  background: linear-gradient(90deg, #5162e0 70%, #9ab5ff 100%);
  transform: translateY(-2px) scale(1.035);
  box-shadow: 0 4px 18px #4456cc44;
}

.save-bar {
  margin-top: 25px;
  font-size: 15px;
  color: #cacde8;
  align-items: flex-start;
}
.save-bar span {
  margin-left: 8px;
  color: #c6c8dd;
}

.stat-box {
  margin: 6px 0 22px 0;
  font-size: 18.5px;
}
.stat-box span {
  display: inline-block;
  margin-right: 22px;
  color: #f8f8fb;
  font-size: 18px;
}
.stat-box b {
  color: #ffe161;
  font-weight: 700;
}
.inv-btn, .enhance-btn {
  font-size: 13px;
  padding: 4px 16px;
  min-width: 42px;
  margin: 0 0 0 5px;
  border-radius: 9px;
}
.inv-btn:hover { background: #697af3; }
.inv-btn:disabled { color: #888; }

.set-bonus {
  color: #ffe161;
  font-weight: bold;
  letter-spacing: 0.8px;
}

/* 전체적으로 폰트 조금 부드럽게 */
body, input, button {
  font-family: 'Malgun Gothic', 'Noto Sans KR', 'Pretendard', sans-serif;
  letter-spacing: 0.08em;
}
#loadslotbox {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 96vh;
  width: 100vw;
  position: absolute;
  top: 0; left: 0;
  background: none;
  z-index: 10;
}
.save-slot-select {
  background: #23223a;
  border-radius: 30px;
  box-shadow: 0 6px 36px #18183360, 0 2px 12px #0008;
  padding: 48px 64px 38px 64px;
  margin-top: 40px;
  font-size: 24px;
  color: #fff;
  min-width: 350px;
}
.save-slot-btn {
  font-size: 23px !important;
  padding: 22px 44px !important;
  border-radius: 13px !important;
  background: #384085 !important;
  color: #fff !important;
  font-weight: 700 !important;
  margin-right: 15px !important;
  margin-bottom: 16px !important;
  box-shadow: 0 2px 14px #2334;
  border: none !important;
  cursor: pointer;
  transition: background 0.14s, transform 0.12s;
}
.save-slot-btn:hover {
  background: #5662d1 !important;
  transform: translateY(-2px) scale(1.025);
}
.save-del-btn {
  background: #ba4545 !important;
  color: #fff !important;
  border-radius: 9px !important;
  font-size: 16px !important;
  padding: 8px 20px !important;
  margin-bottom: 16px !important;
  margin-left: 0px !important;
  border: none !important;
  cursor: pointer;
  transition: background 0.14s;
}
.save-del-btn:hover {
  background: #e65a5a !important;
#equipstatbox {
  margin-bottom: 18px;
  margin-top: -5px;
  display: flex;
  align-items: center;
  padding: 0;
}
.equipstat-flex {
  display: flex;
  flex-direction: column;  /* 세로 정렬 */
  align-items: flex-start; /* 왼쪽 정렬 */
  width: 100%;
  background: #232346;
  border-radius: 10px;
  padding: 7px 18px 7px 18px;
  font-size: 17px;
  color: #ffe161;
  gap: 1px;
}
.equipstat-flex span {
  color: #e3e3e3;
  font-size: 16px;
  letter-spacing: 0.4px;
}
.equipstat-flex b {
  color: #ffe161;
  font-weight: 700;
}
.stat-head {
  font-size: 17px;
  color: #ffe161;
  font-family: 'Malgun Gothic', 'Noto Sans KR', 'Pretendard', sans-serif;
  margin-bottom: 6px;
  letter-spacing: 0.07em;
  font-weight: 600;
}
</style>
</head>
<body>
  <div id="loadslotbox"></div>
  <div id="mainwrap" style="display:none">
    <div id="centerwrap">
      <div id="userinfo" style="display:none"></div>
      <div id="equipstatbox" style="margin-bottom:18px; display:none"></div>
      <div class="log" id="logbox"></div>
    </div>
    <div id="sidebar">
      <div class="btn-bar" id="menubar" style="display:none">
        <button onclick="action('hunt')">사냥</button>
        <button onclick="dungeonEnterUI()">던전</button>
        <button onclick="showExploreMain()" id="btn_explore">탐험</button>
        <button onclick="showChar()">캐릭터</button>
        <button onclick="showInv()">소지품</button>
        <button onclick="showTown()">마을</button>
      </div>
      <div class="save-bar" id="savebar" style="display:none">
        <button onclick="saveGame()">💾 세이브</button>
        <button onclick="showLoad()">불러오기</button>
        <span style="color:#aaa;">(슬롯 <span id="slotsel"></span>)</span>
      </div>
    </div>
  </div>
  <script>
const itemStatTable = {
  "일반":     { base:[0, 2],    atk:[1, 3]   },
  "레어":     { base:[2, 4],    atk:[3, 6]   },
  "유니크":   { base:[4, 7],    atk:[6, 10]  },
  "에픽":     { base:[7, 11],   atk:[10, 15] },
  "레전더리": { base:[12, 18],  atk:[16, 22] },
  "유일":     { base:[18, 27],  atk:[25, 35] }
};
const armorSkillEffectScale = {
  "일반":     1,
  "레어":     1,
  "유니크":   1.2,
  "에픽":     1.5,
  "레전더리": 2,
  "유일":     3
};
const combineRates = { "레어": 0.33, "유니크": 0.20, "에픽": 0.10 };
function combineCost(rarity, level) {
  let base = 1000 + level * 30;
  if (rarity === "유니크") base += 2000;
  if (rarity === "에픽") base += 5000;
  return base;
}
const armorSkillPool = [
  { name: "생명회복",     type: "regen",      base: [1, 2]  },  // 턴마다 %회복
  { name: "피해흡혈",     type: "leech",      base: [1, 2]  },  // 피해의 % 흡수
  { name: "받는피해감소", type: "dmgreduce",  base: [2, 4]  },  // %감소
  { name: "첫피격무시",   type: "ignorehit",  base: [1, 1]  },  // n회
  { name: "사망방지",     type: "deathproof", base: [1, 1]  },  // n회
  { name: "공격반사",     type: "reflect",    base: [2, 3]  },  // %반사
  { name: "회피증가",     type: "evadeup",    base: [3, 4]  },  // %상승
  { name: "실드부여",     type: "shield",     base: [20, 24]}   // 실드량
];
const armorSkillLogEffects = {
  "regen":        { icon:"💚",  color:"#5eff86",  msg: v=>`HP +${v}% 회복` },
  "leech":        { icon:"🩸",  color:"#c9488a",  msg: v=>`피해의 ${v}% 흡혈` },
  "dmgreduce":    { icon:"🛡️", color:"#a1f2ff",  msg: v=>`받는 피해 -${v}%` },
  "ignorehit":    { icon:"🧱",  color:"#c8d7e2",  msg: v=>`첫 피격 무시` },
  "deathproof":   { icon:"⚰️",  color:"#f0f055",  msg: v=>`사망방지` },
  "reflect":      { icon:"🪞",  color:"#8ef6f2",  msg: v=>`공격반사 +${v}%` },
  "evadeup":      { icon:"🏃‍♂️",color:"#8af8a7",  msg: v=>`회피 +${v.toFixed(1)}%` },
  "shield":       { icon:"🛡️", color:"#e3ffd8",  msg: v=>`실드 +${v}` },
};

const statNames = ["STR", "DEX", "INT", "VIT", "LUK"];
const equipSlots = ["머리", "상의", "하의", "손", "신발", "무기", "방패"];
const prefixes = ["불타는", "신속한", "고대의", "빛나는", "강인한", "재빠른", "현자의", "암흑의", "단단한", "용맹한"];
const suffixes = ["광기", "지혜", "속도", "행운", "힘", "수호", "파멸", "마법", "불멸", "용기"];
const rarityOrder = ["일반","레어","유니크","에픽","레전더리","유일","지옥"];
const rarityColors = { "일반":"equip-normal", "레어":"equip-rare", "유니크":"equip-unique", "에픽":"equip-epic", "레전더리":"equip-legend", "유일":"equip-myth","지옥":"equip-inferno" };
const rarityRate   = [60, 20, 5, 1, 0.01, 0,0];
const dungeonRate = [45,25,10,6,1,0.1,0];
const inventoryLimit = 40;
const skillTriggerRate = { "일반": 0.02, "레어": 0.04, "유니크": 0.07, "에픽": 0.10, "레전더리": 0.15, "유일": 0.33 };
const skillGiveRate = { "일반": 0.02, "레어": 0.06, "유니크": 0.10, "에픽": 0.18, "레전더리": 0.25, "유일": 1.0 };
const armorSkillTriggerRate = {"일반": 0.03, "레어": 0.05, "유니크": 0.07, "에픽": 0.10, "레전더리": 0.13, "유일": 0.17};
const slotTypePool = {
  "무기": [
    {name:"검",type:"근접"}, {name:"도끼",type:"근접"}, {name:"창",type:"근접"}, {name:"레이피어",type:"근접"},
    {name:"대검",type:"근접"}, {name:"양손도끼",type:"근접"},
    {name:"활",type:"원거리"}, {name:"석궁",type:"원거리"}, {name:"총",type:"원거리"},
    {name:"원드",type:"마법"}, {name:"스태프",type:"마법"}, {name:"듀얼건",type:"마법"}
  ],
  "방패": [{name:"방패",type:"방어"}],
  "머리": [{name:"투구"},{name:"모자"},{name:"두건"}],
  "상의": [{name:"갑옷"},{name:"로브"},{name:"자켓"}],
  "하의": [{name:"바지"},{name:"레깅스"}],
  "신발": [{name:"부츠"},{name:"신발"},{name:"장화"}],
  "손": [{name:"장갑"},{name:"반지"}]
};
const skillPool = {
  "근접": ["회전베기", "지진강타", "광역참격", "참격", "돌진베기"],
  "원거리": ["연속사격", "관통화살", "저격", "폭발화살", "집중사격"],
  "마법": ["파이어볼", "아이스스톰", "체인라이트닝", "암흑구", "에너지블래스트"]
};
const monsterPrefixes = ["불타는", "사나운", "거대한", "날카로운", "암흑의", "빙결의", "광기의", "번개의", "독기의", "죽음의"];
const monsterNames = [
  "그림자 멧돼지", "빙결 슬라임", "불사른 해골기사", "지옥박쥐", "돌연변이 늑대",
  "암흑의 고블린", "광기의 오우거", "서리골렘", "불꽃 와이번", "죽음의 리치",
  "혼돈의 미노타우르스", "맹독 스콜피온", "무쇠 곰", "흉포한 늑대", "독사",
  "어둠의 암살자", "광포한 곰", "고대의 골렘", "날렵한 팬서", "저주받은 해골전사"
];
const uniqueMonsters = [
  "광휘룡 벨리오로스", "흑섬룡 아벨리오스", "수암룡 타나로토스", "암토룡 우로보로스"
];
const uniqueMonsterPrefixes = {
  "광휘룡 벨리오로스": "광휘",
  "흑섬룡 아벨리오스": "흑섬",
  "수암룡 타나로토스": "수암",
  "암토룡 우로보로스": "토암"
};
// 유일 세트 효과
const uniqueSetBonus = {
  "광휘": { name: "광휘 세트", desc: "1턴 2회 공격" },
  "흑섬": { name: "흑섬 세트", desc: "공격 시 30% 확률로 1턴 스턴" },
  "수암": { name: "수암 세트", desc: "피격 시 40% 확률로 50% 반사" },
  "토암": { name: "토암 세트", desc: "전투 중 1회 사망 시 50% 부활" }
};
let user = null; let saveSlot = 1;
function rint(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
// 몬스터 생성
function makeMonster(level, isDungeon = false) {
if (isDungeon && Math.random() < 0.01) {
  // 유일(보스) 몬스터 - **하향**
  let name = uniqueMonsters[rint(0, uniqueMonsters.length-1)];
  let hp = Math.floor((60 + level*8 + rint(30,80)) * 0.83); // 약 17% 하향
  let atk = Math.floor((12 + level*3 + rint(6,15)) * 0.85); // 약 15% 하향
  let def = Math.floor((level/4 + rint(5,15)) * 0.9);       // 약 10% 하향
  return { name, hp, atk, def, unique: true };
}
  let prefix = monsterPrefixes[rint(0, monsterPrefixes.length - 1)];
  let nameBase = monsterNames[rint(0, monsterNames.length - 1)];
  let name = prefix + " " + nameBase;
  let hp, atk, def;
  if (isDungeon) {
    // 던전 몬스터 (기존처럼 강화)
    hp = Math.floor(20 + level * 4 + rint(0, 16)) + rint(12, 40) + Math.floor(level * 2.5);
    atk = Math.floor(5 + level * 1.3 + rint(1, 4));
    def = Math.floor(level/5 + rint(0, 2));
  } else {
    // 일반(사냥) 몬스터 (더 약하게)
    hp = Math.floor(8 + level * 1.3 + rint(0, 6));
    atk = Math.floor(1.5 + level * 0.4 + rint(0, 1.5));
    def = Math.floor(level/8 + rint(0, 1));
  }
  return { name, hp, atk, def, unique: false };
}
// 세이브/불러오기/슬롯삭제
window.onload = function() { renderSaveSlotSelect(); };
function renderSaveSlotSelect() {
  let html = `<div class="save-slot-select"><b>불러올 슬롯을 선택하세요</b><br>`;
  for(let i=1;i<=3;i++){
    let data = localStorage.getItem("elgasia_save_"+i);
    let btnText = data ? `슬롯${i} (${JSON.parse(data).name} Lv.${JSON.parse(data).level})` : `슬롯${i} (새 시작)`;
    html += `<div style="margin-bottom:8px;display:flex;align-items:center;">
      <button class="save-slot-btn" onclick="startGame(${i})">${btnText}</button>
      <button class="save-del-btn" onclick="deleteSaveSlot(${i})">삭제</button>
    </div>`;
  }
  html += `</div>`;
  document.getElementById("loadslotbox").innerHTML = html;
}
function deleteSaveSlot(slot) {
  if(confirm(`정말로 슬롯${slot}의 저장 데이터를 삭제하시겠습니까? 복구할 수 없습니다.`)){
    localStorage.removeItem("elgasia_save_"+slot);
    renderSaveSlotSelect();
  }
}
function saveGame() {
  if (!user) return;
  localStorage.setItem("elgasia_save_"+saveSlot, JSON.stringify(user));
  log(`<span style='color:#aaf'>슬롯 ${saveSlot}에 저장되었습니다!</span>`);
}
function loadGame(slot) {
  let data = localStorage.getItem("elgasia_save_"+slot);
  if (data) {
    user = JSON.parse(data); saveSlot = slot;
    if(!user.storage) user.storage=[];
    showUI(); updateUser();
    log(`<span style='color:#aff'>불러오기 완료! 슬롯 ${slot}</span>`);
  }
}
function showLoad() {
  let html = `<b>불러올 슬롯 선택</b><br>`;
  for(let i=1;i<=3;i++){
    let data = localStorage.getItem("elgasia_save_"+i);
    let btnText = data ? `슬롯${i} 불러오기 (${JSON.parse(data).name} Lv.${JSON.parse(data).level})` : `슬롯${i} (비어있음)`;
    html += `<button class="save-slot-btn" onclick="loadGame(${i});hideLoad();">${btnText}</button>
    <button class="save-del-btn" onclick="deleteSaveSlot(${i})">삭제</button><br>`;
  }
  html += `<br><button class="inv-btn" onclick="hideLoad()">닫기</button>`;
  document.getElementById("logbox").innerHTML = html;
}
function hideLoad(){ log('이전 화면으로 돌아감'); }
function startGame(slot) {
  saveSlot = slot;
  let data = localStorage.getItem("elgasia_save_"+slot);
  document.getElementById("loadslotbox").style.display = "none";
  document.getElementById("mainwrap").style.display = "";
  if (data) {
    user = JSON.parse(data); if(!user.storage) user.storage=[];
    document.getElementById("loadslotbox").style.display = "none";
    document.getElementById("mainwrap").style.display = "";
    showUI(); updateUser();
    log(`<span style='color:#aff'>불러오기 완료! 슬롯 ${slot}</span>`);
  } else {
    user = {
      name: "용사", level: 1, exp: 0, rebirth: 0, gold: 100,
      stats: [1,1,1,1,1], statmax: 9999, hp: 30, maxhp: 30,
      equip: {}, inv: [], town: {restcount:0,skillstone:1}, stones: 0, storage: []
    };
    document.getElementById("mainwrap").style.display = "";
    showUI(); updateUser();
    log(`<b>환영합니다! 캐릭터 이름을 먼저 정해주세요.</b> <br><div class="namebox"><input type="text" id="newname" maxlength="10" placeholder="캐릭터 이름"/><button class="inv-btn" onclick="setCharName()">확인</button></div>`);
  }
}
function showUI() {
  document.getElementById("loadslotbox").style.display = "none";
  document.getElementById("userinfo").style.display = "";
  document.getElementById("menubar").style.display = "";
  document.getElementById("savebar").style.display = "";
  document.getElementById("slotsel").innerText = saveSlot;
}
function setCharName() {
  let n = document.getElementById("newname").value.trim();
  if (!n) { alert("이름을 입력해주세요."); return; }
  user.name = n;
  updateUser();
  log(`이름이 <b>${n}</b>으로 설정되었습니다!`);
  saveGame();
}
function promptNameChange() {
  let n = prompt("새 캐릭터 이름을 입력하세요", user.name || "");
  if(!n) return;
  user.name = n;
  updateUser(); saveGame();
}
function expNeed(lv){ return Math.floor(Math.pow(lv,1.5)*12)+lv*8; }
function log(msg){ document.getElementById("logbox").innerHTML = msg; }
function updateUser() {
  if(!user.storage) user.storage=[];
  // 기본 정보
  document.getElementById("userinfo").innerHTML = `<div class="stat-box">
    <span>이름 <b>${user.name}</b> <button class="inv-btn" onclick="promptNameChange()">변경</button></span>
    <span>레벨 <b>${user.level}</b></span>
    <span>경험치 <b>${user.exp}/${expNeed(user.level)}</b></span>
    <span>골드 <b>${user.gold}</b></span>
    <span>HP <b>${user.hp}/${user.maxhp}</b></span>
    <span>강화석 <b>${user.stones||0}</b></span>
    <span>창고 <b>${user.storage.length}/100</b></span>
  </div>`;
  document.getElementById("userinfo").style.display = "";

  // 장비 합산 스탯 계산 및 표시
  let baseStats = user.stats.slice();
  let equipStats = user.stats.slice();
  let addATK = 0, addRATK = 0, addMATK = 0, addDEF = 0;
  for (let slot of equipSlots) {
    let eq = user.equip[slot];
    if(eq && eq.stat){
      for(let i=0; i<5; i++){
        equipStats[i] += eq.stat[i]||0;
      }
      addATK += eq.stat[5]||0;
      addRATK += eq.stat[6]||0;
      addMATK += eq.stat[7]||0;
      addDEF += eq.stat[3]||0;
    }
  }
  let totalATK = addATK + equipStats[0];
  let totalRATK = addRATK + equipStats[1];
  let totalMATK = addMATK + equipStats[2];
  let totalDEF = equipStats[3];
  let statLabel = ["STR(근력)","DEX(민첩)","INT(지능)","VIT(체력)","LUK(운)"];
  let equipStr = equipStats.map((v,i)=>`${statLabel[i]}: <b>${v}</b>`).join(" / ");
  let atkStr = `ATK(근접): <b>${totalATK}</b> / RATK(원거리): <b>${totalRATK}</b> / MATK(마법): <b>${totalMATK}</b> / DEF: <b>${totalDEF}</b>`;

document.getElementById("equipstatbox").innerHTML =
  `<div class="equipstat-flex">
     <span>${equipStr}</span>
     <br>
     <span>${atkStr}</span>
   </div>`;
document.getElementById("equipstatbox").style.display = "";
}
function rarityBonus(r){
  if(r=="일반")return 0; if(r=="레어")return 1; if(r=="유니크")return 2;
  if(r=="에픽")return 3; if(r=="레전더리")return 4; if(r=="유일")return 5;
  return 0;
}
// ---- 아이템 생성 (스킬 확률 및 유일 세트/스킬)
function makeItem(allowMyth, isShop, uniqueMonsterName = null, rarityOverride = null, allowInferno = false) {
  let rate = allowMyth ? dungeonRate : rarityRate;
  let localRarityOrder = isShop ? ["일반","레어","유니크"] : rarityOrder;
  let localRate = isShop ? [70,25,5] : rate;
  let rarity = "일반";
  let r = Math.random() * 100, acc = 0;
  for (let i=0;i<localRate.length;i++) { acc += localRate[i]; if (r < acc) { rarity = localRarityOrder[i]; break; } }
  if(!uniqueMonsterName && rarity === "유일") rarity = "레전더리";
  if(uniqueMonsterName) rarity = "유일";
  if (rarityOverride) rarity = rarityOverride;

  let slot = equipSlots[rint(0, equipSlots.length-1)];
  let pool = slotTypePool[slot];
  let baseObj = pool[rint(0, pool.length-1)];
  let itemType = baseObj.name;
  let itemAttackType = baseObj.type || null;

  // ★★★★★ 지옥 등급 (파멸의) 분기 ★★★★★
  if(rarity === "지옥") {
    let isWeapon = (slot === "무기");
    let isArmor = ["머리","상의","하의","손","신발"].includes(slot);
    let name = `파멸의 ${itemType}`;
    let sconf = itemStatTable["유일"];
    // 스탯: 유일의 87~92%로
    let stat = [];
    for(let i=0;i<5;i++) stat.push(rint(Math.floor(sconf.base[0]*0.87), Math.floor(sconf.base[1]*0.92)));
    let atk = itemAttackType === "근접" ? rint(Math.floor(sconf.atk[0]*0.87), Math.floor(sconf.atk[1]*0.92)) : 0;
    let ratk= itemAttackType === "원거리"? rint(Math.floor(sconf.atk[0]*0.87), Math.floor(sconf.atk[1]*0.92)) : 0;
    let matk= itemAttackType === "마법"  ? rint(Math.floor(sconf.atk[0]*0.87), Math.floor(sconf.atk[1]*0.92)) : 0;
    stat.push(atk); stat.push(ratk); stat.push(matk);

    let skill = null, special = null, armorSkill = null;
    if (isWeapon) {
      // 무기스킬 1개
      if (itemAttackType && skillPool[itemAttackType])
        skill = skillPool[itemAttackType][rint(0, skillPool[itemAttackType].length-1)];
      // 특수효과 3종 고정
      special = [
        { type: "strongAtkUp", val: 25 },
        { type: "doubleHit",   val: 15 },
        { type: "ignoreDef",   val: 25 }
      ];
    } else if (isArmor) {
      // 방어구 스킬 1개 (유일보다 약간 약하게)
      let skillObj = armorSkillPool[rint(0, armorSkillPool.length-1)];
      let scale = 2.1; // 유일(3)에 비해 소폭 하향
      let val = rint(skillObj.base[0]*scale, skillObj.base[1]*scale);
      armorSkill = { name: skillObj.name, type: skillObj.type, value: val };
    }
    return {
      name, rarity: "지옥", slot, stat, type: itemType,
      attackType: itemAttackType, skill, enh: 0, ilv: null, unique: false, special, armorSkill
    };
  }
  // ★★★★★ 유일 아이템 (유일 몬스터 드랍) ★★★★★
  if(rarity === "유일" && uniqueMonsterName) {
    let uniqPrefix = uniqueMonsterPrefixes[uniqueMonsterName] || "유일";
    let baseName = baseObj.name;
    let name = `${uniqPrefix}의 ${baseName}`;
    let skill = "";
    if(itemAttackType && skillPool[itemAttackType])
      skill = skillPool[itemAttackType][rint(0, skillPool[itemAttackType].length-1)];
    let stat = [];
    let sconf = itemStatTable["유일"];
    for(let i=0;i<5;i++) stat.push(rint(sconf.base[0],sconf.base[1]));
    let atk = itemAttackType === "근접" ? rint(sconf.atk[0], sconf.atk[1]) : 0;
    let ratk= itemAttackType === "원거리"? rint(sconf.atk[0], sconf.atk[1]) : 0;
    let matk= itemAttackType === "마법"  ? rint(sconf.atk[0], sconf.atk[1]) : 0;
    stat.push(atk); stat.push(ratk); stat.push(matk);
    return {
      name, rarity: "유일", slot, stat, type: baseName, attackType: itemAttackType,
      skill, enh: 0, ilv: null, unique: true, uniqPrefix
    };
  }

  // ★★★★★ 일반~레전더리 아이템 ★★★★★
  let prefix = prefixes[rint(0,prefixes.length-1)];
  let suffix = suffixes[rint(0,suffixes.length-1)];
  let name = `${prefix} ${suffix}의 ${itemType}`;
  let skill = null, skillBase = null, skillBonus=1, trigger = skillTriggerRate[rarity] || 0.05;
  if (itemAttackType && skillPool[itemAttackType]) {
    let chance = skillGiveRate[rarity] || 0.1;
    if(Math.random() < chance) {
      skillBase = skillPool[itemAttackType][rint(0, skillPool[itemAttackType].length-1)];
      skill = prefix ? `${prefix} ${skillBase}` : skillBase;
      if(prefix && prefix.includes("불타는")) skillBonus = 1.2;
    }
  }
  let stat = [];
  let sconf = itemStatTable[rarity];
  for (let i=0;i<5;i++) stat.push(rint(sconf.base[0],sconf.base[1]));
  let atk=0, ratk=0, matk=0;
  if(itemAttackType=="근접") atk = rint(sconf.atk[0],sconf.atk[1]);
  if(itemAttackType=="원거리") ratk = rint(sconf.atk[0],sconf.atk[1]);
  if(itemAttackType=="마법") matk = rint(sconf.atk[0],sconf.atk[1]);
  stat.push(Math.floor(atk * skillBonus));
  stat.push(Math.floor(ratk * skillBonus));
  stat.push(Math.floor(matk * skillBonus));

  // 🟢 방어구 스킬 부여 (방어구만, 무기/방패/유일 제외)
  let armorSkill = null;
  if (["머리","상의","하의","손","신발"].includes(slot) && rarity !== "유일" && Math.random()<0.40) {
    let skillObj = armorSkillPool[rint(0, armorSkillPool.length-1)];
    let scale = armorSkillEffectScale[rarity] || 1;
    let val = rint(skillObj.base[0]*scale, skillObj.base[1]*scale);
    armorSkill = { name: skillObj.name, type: skillObj.type, value: val };
  }

  return {
    name: name, rarity: rarity, slot: slot, stat: stat, type: itemType,
    attackType: itemAttackType, skill: skill, skillBase: skillBase, skillBonus: skillBonus,
    skillTrigger: trigger, enh: 0, ilv: null, unique: false, armorSkill
  };
}
function makeUniqueItem(monsterName, slot){
  const prefix = uniqueMonsterPrefixes[monsterName] || "전설";
  let baseName = slotTypePool[slot][0].name;
  let name = `${prefix}의 ${baseName}`;
  let skill = null;
  switch(prefix){
    case "광휘": skill = "빛의 폭발"; break;
    case "흑섬": skill = "암흑 연쇄"; break;
    case "수암": skill = "물의 파동"; break;
    case "토암": skill = "대지 분쇄"; break;
    default: skill = "전설의 힘";
  }
  let stat = [10,5,5,7,3];
  let atk=15, ratk=0, matk=0;
  if(slot === "무기") atk = 25;
  return {
    name, rarity: "유일", slot, stat, type: baseName,
    attackType: slot === "무기" ? "근접" : null, skill, enh: 0, ilv: null, unique: true, uniqPrefix: prefix
  };
}
function unequip(slot) {
  if (!user.equip[slot]) return;
  if (user.inv.length >= inventoryLimit) {
    log("소지품이 가득 찼다!"); return;
  }
  let item = user.equip[slot];
  user.inv.push(item);        // 인벤토리에 추가
  user.equip[slot] = undefined; // 장착 해제
  showChar(); // 캐릭터창 새로고침
  updateUser();
}
function itemDisplay(item){
  let txt = `<div style="display:flex;align-items:center;">
      <span class="${rarityColors[item.rarity]}" style="font-size:16px;margin-right:7px;min-width:68px;text-align:center;">[${item.rarity}]</span>
      <span style="font-weight:700;font-size:16px;">${item.name}</span>
    </div>`;

  txt += `<div style="margin-left:10px;margin-top:1px;font-size:14px;">`;
  txt += `<span class="stat-label">STR:${item.stat[0]} DEX:${item.stat[1]} INT:${item.stat[2]} VIT:${item.stat[3]} LUK:${item.stat[4]}</span>`;
  if (item.attackType === "근접")   txt += ` <span class="equip-bonus">ATK:${item.stat[5]}</span>`;
  if (item.attackType === "원거리") txt += ` <span class="equip-bonus">RATK:${item.stat[6]}</span>`;
  if (item.attackType === "마법")   txt += ` <span class="equip-bonus">MATK:${item.stat[7]}</span>`;
  if (item.skill)      txt += ` <span class="equip-bonus">스킬:${item.skill}</span>`;
  if (item.armorSkill) txt += ` <span class="equip-bonus">방어구스킬:${item.armorSkill.name}(+${item.armorSkill.value})</span>`;
  // ★★★ 지옥 무기 특수효과 표시
  if (item.special)    txt += ` <span class="equip-bonus">특수효과: ${item.special.map(s=>({
    "strongAtkUp":"강공격확률+25%",
    "doubleHit":"추가공격+15%",
    "ignoreDef":"방어무시+25%"
  }[s.type])).join(", ")}</span>`;
  if (item.enh)        txt += ` <span class="enh-lv">+${item.enh}</span>`;
  txt += `</div>`;
  return txt;
}

// 인벤토리, 착용/판매/일괄판매
function showInv() {
  let invhtml = "";
  user.inv.forEach((item, i) => {
invhtml += `<div class="equipitem">
  <span>${itemDisplay(item)}</span>
  <div class="item-btns">
    <button class="inv-btn" onclick="equipItem(${i})">착용</button>
    <button class="inv-btn" onclick="sellInv(${i})">판매</button>
  </div>
</div>`;
  });
  if (!invhtml) invhtml = "<div style='color:#888'>소지품이 없습니다.</div>";
log(`<b>[소지품]</b> (${user.inv.length}/${inventoryLimit})<br>${invhtml}<br>
  <button class="inv-btn" onclick="showCombineUI()">아이템 합성</button>
  <button class="inv-btn" onclick="sellAllInv()">전체 판매 (착용 제외)</button>
  <button class="inv-btn" onclick="updateUser();log('이전 화면으로 돌아감');">닫기</button>`);
}
function showCombineUI() {
  let html = `<b>[아이템 합성]</b><br>
  <span style="color:#ffe161">동일 등급 아이템 2개를 조합해 상위 등급을 얻을 수 있습니다.<br>
  (유일 등급은 조합 불가, 실패 시 재료 소멸!)</span><br><br>`;

  let valid = ["레어", "유니크", "에픽"];
  let found = false;

  valid.forEach(rarity => {
    // 인벤토리 실제 인덱스와 함께 후보 추출
    let candidates = user.inv
      .map((it, idx) => ({ ...it, _invIdx: idx }))
      .filter(it => it.rarity === rarity && !it.unique);
    if (candidates.length >= 2) {
      found = true;
      html += `<b>${rarity} (${candidates.length}개)</b><br>`;
      for (let i = 0; i < candidates.length; i++) {
        for (let j = i + 1; j < candidates.length; j++) {
          let cost = combineCost(rarity, user.level);
          html += `
            <div class="equipitem combine2row">
              <div class="combine-itembox">${itemDisplay(candidates[i])}</div>
              <div style="font-size:16px;font-weight:bold;text-align:center;margin:4px 0 4px 0;">+</div>
              <div class="combine-itembox">${itemDisplay(candidates[j])}</div>
              <div class="combine-btnbox">
                <button class="inv-btn"
                  onclick="combineItem('${rarity}',${candidates[i]._invIdx},${candidates[j]._invIdx})">
                  합성 (${cost}G, ${Math.round(combineRates[rarity] * 100)}%)
                </button>
              </div>
            </div>
          `;
        }
      }
    }
  });

  if (!found) {
    html += `<div style='color:#888'>합성 가능한 아이템(동일 등급 2개)이 없습니다.</div>`;
  }

  html += `<br><button class="inv-btn" onclick="showInv()">돌아가기</button>`;
  log(html);
}

function combineItem(rarity, idx1, idx2) {
  if (idx1 === idx2) { log('합성 오류: 같은 아이템입니다.'); return; }
  let item1 = user.inv[idx1];
  let item2 = user.inv[idx2];
  if (!item1 || !item2 || item1.rarity !== rarity || item2.rarity !== rarity || item1.unique || item2.unique) {
    log('같은 등급의 일반 아이템 2개가 필요합니다.'); return;
  }
  // ★★ 부위 체크 삭제! ★★
  let cost = combineCost(rarity, user.level);
  if (user.gold < cost) { log('골드가 부족합니다.'); return; }
  user.gold -= cost;
  let [idxA, idxB] = idx1 > idx2 ? [idx1, idx2] : [idx2, idx1]; // 높은 인덱스 먼저
  user.inv.splice(idxA, 1);
  user.inv.splice(idxB, 1);
  if (Math.random() < combineRates[rarity]) {
    let nextRarity = rarity === "레어" ? "유니크" : rarity === "유니크" ? "에픽" : "레전더리";
    let newItem = makeItem(false, false, null, nextRarity);
    // 결과물 부위는 첫 번째 아이템을 따라감
    newItem.slot = item1.slot;
    addInv(newItem);
    log(`<b>합성 성공!</b> [${rarity} 2개] → [${nextRarity} 1개]<br>${itemDisplay(newItem)}<br>
      <button class="inv-btn" onclick="showCombineUI()">다시 합성</button>
      <button class="inv-btn" onclick="showInv()">소지품</button>`);
  } else {
    log(`<span class="dead-log">합성 실패! 재료 아이템 2개 모두 소멸...</span><br>
      <button class="inv-btn" onclick="showCombineUI()">다시 합성</button>
      <button class="inv-btn" onclick="showInv()">소지품</button>`);
  }
  updateUser();
}

function sellAllInv(){
  if(user.inv.length === 0){
    log("판매할 아이템이 없습니다."); return;
  }
  let totalGold = 0;
  let soldNames = [];
  let filteredInv = user.inv.filter(item=>{
    for(let slot of equipSlots){
      if(user.equip[slot] && user.equip[slot].name === item.name) return false;
    }
    return true;
  });
  if(filteredInv.length === 0){
    log("판매할 아이템이 없습니다. (착용 중 아이템 제외)"); return;
  }
filteredInv.forEach(item=>{
  let idx = user.inv.indexOf(item);
  if(idx >= 0) user.inv.splice(idx,1);
  // 아래 공식으로 교체 (개별 판매와 동일하게)
  let sellValue = (10 + user.level * 2) + (rarityBonus(item.rarity) * (40 + user.level * 3));
  totalGold += sellValue;
  soldNames.push(item.name);
});
  user.gold += totalGold;
  log(`착용 중이 아닌 모든 아이템 판매 완료! 총 ${totalGold}골드를 얻었다.<br>판매한 아이템: ${soldNames.join(", ")}<br><button class="inv-btn" onclick="showInv()">소지품으로 돌아가기</button>`);
  updateUser();
}
function equipItem(idx){
  let item = user.inv[idx];
  if(!item || !item.slot || equipSlots.indexOf(item.slot) === -1) return;
  // 부위 확인: 같은 부위에만 장착 가능!
  // 이미 장착 중인 다른 부위에 착용 시도 방지
  // (slot이 정확히 일치하는 경우에만 허용)
  if(user.equip[item.slot]) addInv(user.equip[item.slot]);
  user.equip[item.slot]=item;
  user.inv.splice(idx,1);
  showInv(); updateUser();
}
function sellInv(idx){
  let item = user.inv[idx];
  let sellValue = (10 + user.level * 2) + (rarityBonus(item.rarity) * (40 + user.level * 3));
  user.gold += sellValue;
  user.inv.splice(idx,1);
  log(`${itemDisplay(item)}<br><span style="color:#ffe55e">${sellValue}G에 판매되었습니다!</span><br><button class="inv-btn" onclick="showInv()">돌아가기</button>`);
  updateUser();
}
function addInv(item){
  if(user.inv.length>=inventoryLimit){log("소지품이 가득 찼다!"); return false;}
  user.inv.push(item); return true;
}
// 창고
function showStorage() {
  let html = `<b>[창고]</b> (${user.storage.length}/100)<br>`;
  if(!user.storage.length) html += `<div style='color:#888'>창고에 저장된 아이템이 없습니다.</div>`;
  user.storage.forEach((item, i) => {
    html += `<div class="equipitem">${itemDisplay(item)}
      <div class="item-btns">
        <button class="inv-btn" onclick="moveToInventory(${i})">소지품으로</button>
      </div></div>`;
  });
  html += `<hr><b>[소지품에서 창고로 이동]</b><br>`;
  if(!user.inv.length) html += `<div style='color:#888'>소지품에 아이템이 없습니다.</div>`;
  user.inv.forEach((item,i)=>{
    html += `<div class="equipitem">${itemDisplay(item)}
      <button class="inv-btn" onclick="moveToStorage(${i})">창고로 이동</button>
      </div>`;
  });
  html += `<br><button class="inv-btn" onclick="showTown()">돌아가기</button>`;
  log(html);
}
function moveToStorage(idx) {
  if(user.storage.length >= 100) {
    log("창고가 가득 찼습니다!"); return;
  }
  let item = user.inv[idx];
  user.storage.push(item);
  user.inv.splice(idx,1);
  showStorage();
  updateUser();
}
function moveToInventory(idx) {
  if(user.inv.length >= inventoryLimit) {
    log("소지품이 가득 찼습니다!"); return;
  }
  let item = user.storage[idx];
  user.inv.push(item);
  user.storage.splice(idx,1);
  showStorage();
  updateUser();
}
// 캐릭터창(기본/장비합산 스탯)
function showChar() {
  let baseStats = user.stats.slice();
  let equipStats = user.stats.slice();
  let addATK = 0, addRATK = 0, addMATK = 0, addDEF = 0;
  for (let slot of equipSlots) {
    let eq = user.equip[slot];
    if(eq && eq.stat){
      for(let i=0; i<5; i++){
        equipStats[i] += eq.stat[i]||0;
      }
      addATK += eq.stat[5]||0;
      addRATK += eq.stat[6]||0;
      addMATK += eq.stat[7]||0;
      addDEF += eq.stat[3]||0;
    }
  }
  let totalATK = addATK + equipStats[0];
  let totalRATK = addRATK + equipStats[1];
  let totalMATK = addMATK + equipStats[2];
  let totalDEF = equipStats[3];
  let statLabel = ["STR(근력)","DEX(민첩)","INT(지능)","VIT(체력)","LUK(운)"];
  let baseStr = baseStats.map((v,i)=>`${statLabel[i]}: ${v}`).join(" / ");
  let equipStr = equipStats.map((v,i)=>`${statLabel[i]}: ${v}`).join(" / ");

let html = `<b>[캐릭터]</b><br>
<div class="stat-head"> Lv.${user.level} / 환생: ${user.rebirth||0}회 / 경험치: ${user.exp} / HP: ${user.hp}/${user.maxhp} / 골드: ${user.gold} / 강화석: ${user.stones||0}</div>
<b>기본 스탯</b><br>${baseStr}<br>
<b>장비합산 스탯</b><br>${equipStr}<br>
<b>공격/방어력</b><br>ATK: ${totalATK} / RATK: ${totalRATK} / MATK: ${totalMATK} / DEF: ${totalDEF}<br><br>
<b>장착 장비</b><br>`;

  // 장착 장비도 인벤토리처럼 동일하게 출력
  for(let slot of equipSlots) {
    let eq = user.equip[slot];
    html += `<div class="equipitem">`;
    if (eq) {
      html += `
        <span>${itemDisplay(eq)}</span>
        <div class="item-btns">
          <button class="inv-btn" onclick="unequip('${slot}')">해제</button>
        </div>
      `;
    } else {
      html += `<span style="color:#888">[${slot}] 비어있음</span>`;
    }
    html += `</div>`;
  }

  let setBonusKey = checkUniqueSetBonus();
  let setBonusMsg = setBonusKey ? `<br><span class="set-bonus">[${uniqueSetBonus[setBonusKey].name} 세트 효과: ${uniqueSetBonus[setBonusKey].desc}]</span>` : "";
  html += setBonusMsg;
  html += `<br><button class="inv-btn" onclick="showInv()">소지품</button>
  <button class="inv-btn" onclick="updateUser();log('이전 화면으로 돌아감');">닫기</button>`;
  log(html);
}

function showGacha() {
  let html = `<b>[가챠 상점]</b><br>
  <span style="color:#ffe161">골드로 무작위 보상을 뽑을 수 있습니다!</span><br>
  <button class="inv-btn" onclick="gachaRoll(1)">1회 뽑기 (2,000G)</button>
  <button class="inv-btn" onclick="gachaRoll(10)">10회 뽑기 (18,000G, 10% 할인)</button>
  <br><button class="inv-btn" onclick="showTown()">돌아가기</button>`;
  log(html);
}

// 마을/상점/강화
function showTown(){
  log(`<b>[마을]</b><br>
    <button class="inv-btn" onclick="innRest()">여관(휴식)</button>
    <button class="inv-btn" onclick="showShop()">장비상점</button>
    <button class="inv-btn" onclick="showEnhance()">강화소</button>
    <button class="inv-btn" onclick="showGacha()">가챠상점</button>
    <button class="inv-btn" onclick="showStorage()">창고</button>
    <button class="inv-btn" onclick="rebirth()">환생</button>
    <button class="inv-btn" onclick="updateUser();log('이전 화면으로 돌아감');">닫기</button>`);
}
function innRest(){
  let cost=20+user.level*5;
  if(user.gold<cost){log("골드가 부족합니다.");return;}
  user.gold-=cost; user.hp=user.maxhp;
  log(`여관에서 휴식 후 HP 전부 회복! (${cost}골드 소모)<br><button class='inv-btn' onclick='showTown()'>돌아가기</button>`);
  updateUser();
}
function showShop() {
  let items = [];
  for(let i=0;i<5;i++) items.push(makeItem(false, true)); // isShop = true
  let html = `<div class="shop-title">[장비 상점] (새로고침시 상품 변경, 에픽 등급 이상은 미출현)</div>`;
  items.forEach((item, idx) => {
    html += `<div class="equipitem">${itemDisplay(item)}
      <div class="item-btns">
        <button class="inv-btn" onclick="buyShopItem(${idx})">구매 (${50+user.level*8}G)</button>
      </div></div>`;
  });
  html += `<br><button class="inv-btn" onclick="showTown()">돌아가기</button>`;
  log(html); window.shopItems = items;
}
function buyShopItem(idx) {
  let item = window.shopItems[idx];
  let cost = 50 + user.level*8;
  if(user.gold<cost){log("골드가 부족합니다.");return;}
  if(user.inv.length>=inventoryLimit){log("소지품이 가득 찼다!");return;}
  user.gold -= cost;
  user.inv.push(item);
  log(`구매 완료!<br>${itemDisplay(item)}<br><button class="inv-btn" onclick="showShop()">상점으로</button>`);
  updateUser();
}
function showEnhance() {
  let html = `<div class="shop-title">[장비 강화]</div>`;
  let equips = Object.values(user.equip).filter(e => e);
  if (!equips.length) {
    html += `<div style="color:#888">강화할 장비가 없습니다.</div>`;
  } else {
    equips.forEach((eq, idx) => {
      html += `<div class="equipitem">${itemDisplay(eq)}
        <div class="item-btns">
          <button class="enhance-btn" onclick="enhanceItem('${eq.slot}')">강화</button>
        </div></div>`;
    });
  }
  html += `<br><button class="inv-btn" onclick="showTown()">돌아가기</button>`;
  log(html);
}
function gachaRoll(count) {
  let cost = (count === 10) ? 18000 : 2000;
  if(user.gold < cost) {
    log("골드가 부족합니다!"); return;
  }
  user.gold -= cost;
  let results = [];
  for(let i=0; i<count; i++) {
    let r = Math.random() * 100;
    let item;
    if(r < 0.001) { // 유일(신화)
      item = makeItem(true, false, null, "유일");
      results.push(`🟣 ${itemDisplay(item)}`); addInv(item);
    } else if(r < 0.201) { // 레전더리
      item = makeItem(false, false, null, "레전더리");
      results.push(`🟡 ${itemDisplay(item)}`); addInv(item);
    } else if(r < 2.201) { // 에픽
      item = makeItem(false, false, null, "에픽");
      results.push(`🟠 ${itemDisplay(item)}`); addInv(item);
    } else if(r < 9.201) { // 유니크
      item = makeItem(false, false, null, "유니크");
      results.push(`🔵 ${itemDisplay(item)}`); addInv(item);
    } else if(r < 34.201) { // 강화석
      let stone = rint(1, 10);
      user.stones = (user.stones||0) + stone;
      results.push(`<span style="color:#77e">💎 강화석 ${stone}개 획득!</span>`);
    } else if(r < 49.201) { // 골드 환급
      let gold = rint(150, 300);
      user.gold += gold;
      results.push(`<span style="color:#ffe161">💰 보너스 골드 ${gold} 획득!</span>`);
    } else { // 나머지: 일반~유니크
      item = makeItem(false, false);
      results.push(`⚪️ ${itemDisplay(item)}`); addInv(item);
    }
  }
  log(`<b>[가챠 결과]</b><br>${results.join("<br>")}<br>
    <button class="inv-btn" onclick="showGacha()">가챠 상점으로</button>
    <button class="inv-btn" onclick="showTown()">마을로</button>`);
  updateUser();
}
function enhanceItem(slot){
  let eq = user.equip[slot];
  if(!eq) return;
  let lv = eq.enh || 0;
  if(lv>=20){ log("최대 강화 단계입니다."); return; }
  let needStone = lv < 5 ? [1,2,4,8,20][lv] : lv < 10 ? 20*Math.pow(2, lv-4) : lv < 15 ? 60*Math.pow(3, lv-9) : 120*Math.pow(4, lv-14);
  let needGold = 100 + lv * 50;
  if(user.stones < needStone){ log(`강화석이 부족합니다. (필요: ${needStone}, 보유: ${user.stones})`); return; }
  if(user.gold < needGold){ log(`골드가 부족합니다. (필요: ${needGold}, 보유: ${user.gold})`); return; }
  let prob = lv < 4 ? 1 : lv < 10 ? 0.5-(lv-4)*0.08 : lv < 15 ? 0.12-(lv-10)*0.025 : 0.04-(lv-15)*0.007;
  if(prob < 0.01) prob = 0.01;
  let succ = Math.random() < prob;

  // 반드시 먼저 차감!
  user.stones -= needStone;
  user.gold -= needGold;

  if(succ){
    eq.enh = lv + 1;
    if(eq.slot === "무기") {
      let atkIndex = 5;
      if(eq.attackType === "원거리") atkIndex = 6;
      else if(eq.attackType === "마법") atkIndex = 7;
      eq.stat[atkIndex] = (eq.stat[atkIndex] || 0) + rint(1,3);
      log(`<span class="succ-msg">[+${eq.enh} 강화 성공! 주요 공격력이 상승했습니다!]</span><br>
        <span style="color:#ffe161">골드 ${needGold} / 강화석 ${needStone} 소모</span>`);
    } else {
      let statIdx = rint(0,4);
      eq.stat[statIdx] = (eq.stat[statIdx]||0) + rint(1,3);
      log(`<span class="succ-msg">[+${eq.enh} 강화 성공! 스탯이 랜덤으로 상승했습니다!]</span><br>
        <span style="color:#ffe161">골드 ${needGold} / 강화석 ${needStone} 소모</span>`);
    }
  } else {
    log(`<span class="fail-msg">[강화 실패]</span><br>
      <span style="color:#ffe161">골드 ${needGold} / 강화석 ${needStone} 소모</span>`);
  }
  updateUser();
  showEnhance();
}// 세트보너스 체크(유일 전용)
function checkUniqueSetBonus() {
  const armorSlots = ["머리", "상의", "하의", "손", "신발"];
  let found = { 광휘:0, 흑섬:0, 수암:0, 토암:0 };
  for(let slot of armorSlots){
    let eq = user.equip[slot];
    if(eq && eq.rarity === "유일") {
      let pre = eq.uniqPrefix || (eq.name.split("의")[0]);
      if(found[pre] !== undefined) found[pre]++;
    }
  }
  for(let key in found) if(found[key] >= 4) return key; // 4셋 보유시 반환
  return null;
}
function triggerArmorSkills(timing, opts) {
  // opts: {attackDmg, skillAttack, battleLog, userhp, monhp, shieldObj, gotHit, turn, monsterDmg}
  let anyTriggered = false;
  for (let slot of equipSlots) {
    let eq = user.equip[slot];
    if (eq && eq.armorSkill) {
      let rarity = eq.rarity || "일반";
      let trigRate = armorSkillTriggerRate[rarity] || 0.02;
      if (Math.random() < trigRate) {
        let v = eq.armorSkill.value;
        let type = eq.armorSkill.type;
        let eff = armorSkillLogEffects[type];
        switch (type) {
          case "regen":
            if (timing === "turn") {
              let heal = Math.max(1, Math.floor(user.maxhp * (v / 100)));
              opts.userhp.val = Math.min(user.maxhp, opts.userhp.val + heal);
              opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg(heal)}</span>`);
              anyTriggered = true;
            }
            break;
          case "leech":
            if (timing === "attack" && opts.attackDmg > 0) {
              let leech = Math.max(1, Math.floor(opts.attackDmg * (v / 100)));
              opts.userhp.val = Math.min(user.maxhp, opts.userhp.val + leech);
              opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg(leech)}</span>`);
              anyTriggered = true;
            }
            break;
          case "skillheal":
            if (timing === "attack" && opts.skillAttack && opts.attackDmg > 0) {
              let sheal = Math.max(1, Math.floor(opts.attackDmg * (v / 100)));
              opts.userhp.val = Math.min(user.maxhp, opts.userhp.val + sheal);
              opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg(sheal)}</span>`);
              anyTriggered = true;
            }
            break;
          case "dmgreduce":
            if (timing === "defend") {
              opts.shieldObj.reducePct += v;
              opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg(v)}</span>`);
              anyTriggered = true;
            }
            break;
          case "reflect":
            if (timing === "defend") {
              opts.shieldObj.reflectPct += v;
              opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg(v)}</span>`);
              anyTriggered = true;
            }
            break;
          case "evadeup":
            if (timing === "defend") {
              opts.shieldObj.evadeAdd += v;
              opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg(v)}</span>`);
              anyTriggered = true;
            }
            break;
          case "shield":
            if (timing === "defend" || timing === "turn") {
              opts.shieldObj.shield += v;
              opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg(v)}</span>`);
              anyTriggered = true;
            }
            break;
          case "ignorehit":
            if (timing === "gotHit" && opts.gotHit) {
              if (!eq._usedIgnore) {
                eq._usedIgnore = true;
                opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg()}</span>`);
                opts.monsterDmg.val = 0;
                anyTriggered = true;
              }
            }
            break;
          case "deathproof":
            if (timing === "death" && opts.userhp.val <= 0) {
              if (!eq._usedDeathProof) {
                eq._usedDeathProof = true;
                opts.userhp.val = Math.floor(user.maxhp * 0.3);
                opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg()}</span>`);
                anyTriggered = true;
              }
            }
            break;
          case "skillred":
            if (timing === "defend" && opts.isSkillHit) {
              opts.shieldObj.skillRed += v;
              opts.battleLog.push(`<span style="color:${eff.color}">${eff.icon} [${slot}] ${eff.msg(v)}</span>`);
              anyTriggered = true;
            }
            break;
        }
      }
    }
  }
  return anyTriggered;
}

// --- 전투 메인 함수 (수정 완성본) ---
function battle(type, diffKey) {
  let isDungeon = (type === "dungeon");
  let monster = makeMonster(user.level, isDungeon);
  let monhp = monster.hp + (isDungeon ? rint(5,18) : 0);
  let userhp = { val: user.hp };
  let dropMsg = "";
  let battleLog = [];
  // [수정] --- 장비+스탯 합산 공식 (스탯창과 동일하게)
  let baseStats = user.stats.slice();
  let equipStats = user.stats.slice();
  let addATK = 0, addRATK = 0, addMATK = 0, addDEF = 0;
  for (let slot of equipSlots) {
    let eq = user.equip[slot];
    if(eq && eq.stat){
      for(let i=0; i<5; i++){
        equipStats[i] += eq.stat[i]||0;
      }
      addATK += eq.stat[5]||0;
      addRATK += eq.stat[6]||0;
      addMATK += eq.stat[7]||0;
      addDEF += eq.stat[3]||0;
    }
  }
  let totalATK   = addATK + equipStats[0];
  let totalRATK  = addRATK + equipStats[1];
  let totalMATK  = addMATK + equipStats[2];
  let totalDEF   = equipStats[3];

  let weapon = user.equip["무기"];
  let myATK = totalATK;
  if (weapon) {
    if (weapon.attackType == "원거리") myATK = totalRATK;
    else if (weapon.attackType == "마법") myATK = totalMATK;
  }
  let myDEF = totalDEF;

  let setBonusKey = checkUniqueSetBonus();
  let hasGwanghui = setBonusKey === "광휘";
  let rebirthUsed = false;
  let maxTurn = 10;
  let shieldObj = { reducePct:0, reflectPct:0, evadeAdd:0, shield:0, skillRed:0 };
  let skillTurn = [], finalSkillMsg = "";

  let turn;
  for(turn=1; turn<=maxTurn && userhp.val>0 && monhp>0; turn++) {
    // 턴 시작 효과
    triggerArmorSkills('turn', {battleLog, userhp, monhp, shieldObj});
    let intChance = Math.min(user.stats[2]/9999 * 0.7, 0.7);
    if(Math.random() < intChance) {
      let heal = Math.floor(user.maxhp * 0.2);
      userhp.val = Math.min(user.maxhp, userhp.val + heal);
      battleLog.push(`<b>[${turn}턴]</b> <span class="skill-log">✨ [마력 효과] HP ${heal} 회복!</span> (내 HP:${userhp.val})`);
    }

    // 스턴 처리
    if(user.stunned && user.stunned > 0) {
      battleLog.push(`<b>[${turn}턴]</b> <span class="set-bonus">⏳ [흑섬 세트] 적이 스턴 상태로 행동불가!</span>`);
      user.stunned--;
    }

    // 공격 횟수
    let attacksThisTurn = 1;
    if(hasGwanghui) attacksThisTurn += 1;
    let dexChance = Math.min(user.stats[1]/9999 * 0.7, 0.7);
    let dexExtra = (Math.random() < dexChance) ? 1 : 0;
    if(dexExtra) attacksThisTurn += 1;

    // [공격 루프]
    for(let atkNum=0; atkNum<attacksThisTurn; atkNum++) {
      let effects = [];
      let dmg = rint(myATK-2, myATK+3);
      // 몬스터 방어력 적용
      dmg = Math.floor(dmg * 100 / (100 + monster.def));
      if (dmg < 1) dmg = 1;
      let isStrong = (Math.random() < Math.min(user.stats[0]/9999 * 0.7, 0.7));
      if(isStrong) {
        dmg = dmg * 2;
        effects.push(`<span class="skill-log">💥 [힘: 강공격]</span>`);
      }

      // 무기스킬
      let isSkill = weapon && weapon.skill && Math.random() < (weapon.skillTrigger||0);
      if(isSkill) {
        dmg = Math.floor(dmg*1.8) + rint(1,5);
        skillTurn.push(turn);
        finalSkillMsg = `[스킬 발동] ${weapon.skill}로 강력한 일격!`;
        effects.push(`<span class="skill-log">🔥 [무기스킬: ${weapon.skill}]</span>`);
      }

      // 방어구 스킬(흡혈 등)
      triggerArmorSkills('attack', {
        attackDmg: dmg, skillAttack: isSkill, battleLog, userhp, monhp, shieldObj
      });

      // 흑섬(스턴)
      if(setBonusKey==="흑섬" && Math.random()<0.3){
        user.stunned = 1;
        effects.push(`<span class="set-bonus">⏳ [흑섬 세트: 스턴!]</span>`);
      }

      let monsterNameDisplay = monster.unique ? `<span class="unique-monster">${monster.name}</span>` : monster.name;
      let finalDmg = Math.floor(dmg * 100 / (100 + (monster.def||0)));
      if (finalDmg < 1) finalDmg = 1;
      monhp -= finalDmg;
      if(monhp < 0) monhp = 0;
      battleLog.push(`<b>[${turn}턴 공격${atkNum+1}]</b> ${effects.join(" ")}<span style="font-weight:bold;">${user.name}의 공격!</span> <span class="dmg-log">${monsterNameDisplay}에게 ${finalDmg}의 피해</span> (몬스터 HP:${Math.max(monhp,0)})`);
      if(monhp <= 0) break;
    }
    if(monhp <= 0) break;
    if(user.stunned && user.stunned > 0) { user.stunned--; continue; }

    // 몬스터 공격
    let monsterRawDmg = monster.atk + rint(-2, 3);
    if (monsterRawDmg < 1) monsterRawDmg = 1;
    let monsterDmgVal = Math.floor(monsterRawDmg * 100 / (100 + myDEF));
    if (monsterDmgVal < 1) monsterDmgVal = 1;
    let monsterDmg = { val: monsterDmgVal };
    triggerArmorSkills('defend', {
      battleLog, userhp, monhp, shieldObj, isSkillHit: false
    });

    if (shieldObj.shield > 0) {
      let absorb = Math.min(shieldObj.shield, monsterDmg.val);
      shieldObj.shield -= absorb;
      monsterDmg.val -= absorb;
      battleLog.push(`<span style="color:#e3ffd8;font-weight:bold;">🛡️ [실드] 피해 ${absorb} 흡수 (잔여 ${shieldObj.shield})</span>`);
    }
    if (shieldObj.reflectPct > 0) {
      let reflect = Math.floor(monsterDmg.val * (shieldObj.reflectPct / 100));
      monhp -= reflect;
      battleLog.push(`<span style="color:#8ef6f2">🪞 [반사] ${reflect} 반사</span>`);
    }
    if (shieldObj.reducePct > 0) {
      monsterDmg.val = Math.max(1, Math.floor(monsterDmg.val * (1-shieldObj.reducePct/100)));
    }
    if (shieldObj.skillRed > 0) {
      monsterDmg.val = Math.max(1, Math.floor(monsterDmg.val * (1-shieldObj.skillRed/100)));
    }
    let evadeChance = Math.min(user.stats[4]/9999 * 0.7, 0.7) + (shieldObj.evadeAdd/100);
    if(Math.random() < evadeChance) {
      battleLog.push(`<span class="dmg-log">${monster.unique ? `<span class="unique-monster">${monster.name}</span>` : monster.name}의 공격! → <b>🌀 [회피!]</b> (내 HP:${Math.max(userhp.val,0)})</span>`);
      continue;
    }
    let gotHit = true;
    triggerArmorSkills('gotHit', {battleLog, userhp, monhp, shieldObj, gotHit, monsterDmg});
    if(monsterDmg.val <= 0) continue;

    userhp.val -= monsterDmg.val;
    battleLog.push(`${monster.unique ? `<span class="unique-monster">${monster.name}</span>` : monster.name}의 공격! <span class="dmg-log">${user.name}에게 ${monsterDmg.val} 피해</span> (내 HP:${Math.max(userhp.val,0)})`);

    triggerArmorSkills('death', {battleLog, userhp, monhp, shieldObj});

    if(userhp.val<=0 && setBonusKey==="토암" && !rebirthUsed){
      rebirthUsed = true; userhp.val = Math.floor(user.maxhp*0.5);
      battleLog.push(`<span class="set-bonus">🪨 [토암 세트: 1회 부활! HP ${userhp.val}로 부활]</span>`);
    }
    if(userhp.val <= 0) { userhp.val = 0; break; }
    shieldObj = { reducePct:0, reflectPct:0, evadeAdd:0, shield:shieldObj.shield, skillRed:0 };
  }
  turn--;

  // 플래그 초기화
  for (let slot of equipSlots) {
    let eq = user.equip[slot];
    if(eq) {
      delete eq._usedIgnore;
      delete eq._usedDeathProof;
    }
  }

  // 보상 및 결과 처리 (이 부분 동일)
  let win = (monhp<=0 && turn<=maxTurn);
  if(turn>maxTurn) win = false;
  let baseExp = isDungeon ? Math.floor(user.level*4)+rint(16,32) : Math.floor(user.level*1.7)+rint(6,16);
  let baseGold = isDungeon ? rint(32,80)+Math.floor(user.level*4.2) : rint(10,20)+Math.floor(user.level*1.4);
  let hpLoss = user.hp-userhp.val;
  let rewardMsg = "";
  if(win){
    let gain = baseExp; let gold = baseGold; let dropMsg = "", stoneMsg="";
    // 탐험에서만 등급 제한 보상 적용
    if(type === "explore") {
      if(Math.random() < 0.5) {
        let item = getExploreItem(diffKey);
        if(addInv(item)) dropMsg = `<br>아이템 획득! ${itemDisplay(item)}`;
      }
    } else {
      if (Math.random() < (isDungeon?0.5:0.25)) {
        let item = makeItem(isDungeon, false, monster.unique ? monster.name : null);
        if (addInv(item)) dropMsg = `<br>아이템 획득! ${itemDisplay(item)}`;
      }
    }
    if (Math.random() < (isDungeon ? 0.15 : 0.10)) {
      let stonesDrop = rint(1, 10);
      user.stones = (user.stones || 0) + stonesDrop;
      stoneMsg = `<br><span style="color:#77e;">강화석 ${stonesDrop}개를 획득했다!</span>`;
    }
    user.exp += gain; user.gold += gold;
    user.hp = Math.max(1,userhp.val);
    let setBonusDesc = setBonusKey ? `<br><span class="set-bonus">[${uniqueSetBonus[setBonusKey].name} 세트 효과: ${uniqueSetBonus[setBonusKey].desc}]</span>` : "";
    rewardMsg = `<br><b>승리!</b> 경험치 +${gain}, 골드 +${gold}, HP -${hpLoss}${finalSkillMsg?`<br><span class="skill-log">${finalSkillMsg}</span>`:""}${setBonusDesc}${dropMsg}${stoneMsg}`;
    levelupCheck();
  } else {
    user.hp = userhp.val; if(userhp.val<=0) user.hp=1;
    rewardMsg = `<br><span class="dead-log">패배! 10턴 초과 혹은 몬스터에게 쓰러졌습니다. HP ${userhp.val<=0?'1로 복구':`(${userhp.val})`}.</span>`;
    if(isDungeon && userhp.val<=0){
      let lost = [];
      if(Math.random()<0.2){
        let candidates = equipSlots.filter(s=>user.equip[s]);
        if(candidates.length){
          let lostSlot = candidates[rint(0,candidates.length-1)];
          let lostItem = user.equip[lostSlot];
          user.equip[lostSlot] = undefined; lost.push(lostItem.name);
        }
      }
      if(lost.length) rewardMsg += `<br><span class="dead-log">[장비 손실] ${lost.join(", ")}</span>`;
    }
  if (exploring) exploring.done = true;
  }
  log(`[${isDungeon?'던전':'사냥'}] <span class="monname">${monster.unique ? `<span class="unique-monster">${monster.name}</span>` : monster.name}</span>과의 턴제 전투 (최대 10턴)<br>` + battleLog.join("<br>") + rewardMsg);
  updateUser();
}
function action(type){
  // HP가 1일 때는 사냥, 던전 모두 입장/실행 불가
  if(user.hp <= 1){
    log("<span class='dead-log'>HP가 1일 때는 전투를 할 수 없습니다! 여관에서 회복하세요.</span>");
    return;
  }
  battle(type);
}
function dungeonEnterUI() {
  log(`<b>[던전 입장]</b><br>
  <span style="color:#ffd700;">던전에서 죽으면 확률적으로 장비를 잃을 수 있습니다.</span><br><br>
  <button class="inv-btn" onclick="dungeonAction()">입장하기</button>
  <button class="inv-btn" onclick="updateUser();log('이전 화면으로 돌아감');">취소</button>`);
}
function dungeonAction(){ battle("dungeon"); }
// 레벨업 및 스탯
function levelupCheck(){
  while(user.exp>=expNeed(user.level) && user.level<999){
    user.exp -= expNeed(user.level);
    user.level++;
    statRandAdd(user.stats);
    user.maxhp += 5+rint(0,5);
    user.hp = user.maxhp;
    log(`[LEVEL UP!] Lv.${user.level}로 올랐습니다!`);
  }
}
function statRandAdd(stats){
  let idx = rint(0,stats.length-1);
  stats[idx]++;
}
let exploring = null;
let exploringStageSource = "hunt"; // battle 타입 저장용
const exploreMaps = [
  "초원", "숲", "동굴", "폐허", "사막", "빙설", "화산", "늪지", "유적", "산맥",
  "오아시스", "분화구", "흑요암 협곡", "빙하 대지", "황혼 고원"
];
function showExploreMain() {
  if(user.level < 150){
    log("<span class='dead-log'>Lv.150부터 탐험이 가능합니다!</span>");
    return;
  }
  let html = `<b>[탐험]</b><br>
    <span style='color:#ffe161'>난이도를 선택하면 랜덤 지역에서 탐험이 시작됩니다.</span><br>`;
  difficulties.forEach(diff => {
    html += `<button class="inv-btn" onclick="beginExploreRandomMap('${diff.key}')">${diff.label}</button>
             - <span style='color:#ccc'>${diff.desc} (Lv.${diff.minLv}+)</span><br>`;
  });
  html += `<button class="inv-btn" onclick="updateUser();log('이전 화면으로 돌아감');">닫기</button>`;
  log(html);
}
function beginExploreRandomMap(diffKey) {
  let diff = difficulties.find(d => d.key === diffKey);
  if(user.level < diff.minLv){
    log(`<span class='dead-log'>${diff.label} 난이도는 Lv.${diff.minLv}부터 입장 가능합니다!</span>`);
    return;
  }
  // 맵 무작위 배정
  let mapIdx = rint(0, exploreMaps.length-1);
  let zone = exploreMaps[mapIdx];
  // 이하 기존 탐험 시작 로직 (zone, diff.key)
  beginExplore(zone, diff.key);
}
const diffMap = { 
  "쉬움": 0.85, 
  "보통": 1.2, 
  "어려움": 1.5, 
  "매우어려움": 2.0, 
  "지옥": 2.7 
};
const difficulties = [
  { key:"쉬움", minLv:150, label:"쉬움(EASY)", desc:"쉬운난이도입니다.", bonus:0.7 },
  { key:"보통", minLv:180, label:"보통(NORMAL)", desc:"기본", bonus:1.3 },
  { key:"어려움", minLv:260, label:"어려움(HARD)", desc:"어려운 난이도 입니다.", bonus:2.1 },
  { key:"매우어려움", minLv:420, label:"매우 어려움(HELL)", desc:"도전을 좋아하시나요?", bonus:3.3 },
  { key:"지옥", minLv:680, label:"지옥(INFERNO)", desc:"극악", bonus:6.5 }
];
function chooseExploreZone(zone) {
  let html = `<b>[${zone} - 난이도 선택]</b><br>`;
  difficulties.forEach(diff => {
    html += `<button class="inv-btn" onclick="beginExplore('${zone}','${diff.key}')">${diff.label}</button> - <span style='color:#ccc'>${diff.desc} (Lv.${diff.minLv}+)</span><br>`;
  });
  html += `<button class="inv-btn" onclick="showExploreMain()">난이도 다시 선택</button>`;
  log(html);
}
function beginExplore(zone, diff) {
  if (exploring && !exploring.done) {
    log("<span class='dead-log'>이미 탐험 중입니다! 진행을 끝내세요.</span>");
    return;
  }
  const maxStage = rint(6, 10); // 6~10스테이지
  exploring = {
    zone, diff, done: false,
    stage: 1, maxStage,
    progress: [],
    rewardSum: { gold: 0, exp: 0, stones: 0, item: 0 }
  };
  showExploreProgress();
}
// 탐험 이벤트 전투 리워드 보상 - 난이도별 적용
function getExploreRewardRarity(diff) {
  // 난이도별 보상 등급과 확률
  // [등급, 확률] (전체합 100%는 아니어도 됨)
  const table = {
    "쉬움": [
      ["지옥",   0.002],
      ["유일",   0.01],
      ["레전더리", 0.15],
      ["에픽",   1],
      ["유니크", 5],
      ["레어",   30],
      ["일반",   100]
    ],
    "보통": [
      ["지옥",   0.005],
      ["유일",   0.03],
      ["레전더리", 0.3],
      ["에픽",   2],
      ["유니크", 9],
      ["레어",   40],
      ["일반",   100]
    ],
    "어려움": [
      ["지옥",   0.01],
      ["유일",   0.07],
      ["레전더리", 1],
      ["에픽",   4],
      ["유니크", 18],
      ["레어",   50],
      ["일반",   100]
    ],
    "매우어려움": [
      ["지옥",   0.025],
      ["유일",   0.17],
      ["레전더리", 2.5],
      ["에픽",   7],
      ["유니크", 28],
      ["레어",   65],
      ["일반",   100]
    ],
    "지옥": [
      ["지옥",   0.05],
      ["유일",   0.25],
      ["레전더리", 5],
      ["에픽",   10],
      ["유니크", 38],
      ["레어",   80],
      ["일반",   100]
    ],
  };
  let rates = table[diff] || table["쉬움"];
  let r = Math.random() * 100;
  let acc = 0;
  for (let [rarity, prob] of rates) {
    acc += prob;
    if (r < acc) return rarity;
  }
  return "일반";
}
function getExploreItem(diff) {
  let rarity = getExploreRewardRarity(diff);
  return makeItem(false, false, null, rarity);
}
function showExploreProgress() {
  if (!exploring) return;
  let html = `<b>[탐험: ${exploring.zone} / ${exploring.diff}]</b><br>
  진행도: ${exploring.stage > exploring.maxStage ? exploring.maxStage : exploring.stage} / ${exploring.maxStage}<br>
  <span style="color:#ffe161">획득: GOLD ${exploring.rewardSum.gold} / EXP ${exploring.rewardSum.exp} / 강화석 ${exploring.rewardSum.stones} / 아이템 ${exploring.rewardSum.item}</span><br>`;
  if (exploring.done || exploring.stage > exploring.maxStage) {
    html += `<br><b>탐험 종료!</b><br>
    <span style="color:#b8ffad">보상합계:<br>
    GOLD:${exploring.rewardSum.gold}, EXP:${exploring.rewardSum.exp}, 강화석:${exploring.rewardSum.stones}, 아이템:${exploring.rewardSum.item}</span><br>
    <button class="inv-btn" onclick="exploring=null;updateUser();log('이전 화면으로 돌아감');">닫기</button>`;
    log(html);
    exploring = null;
    return;
  }
  html += `<button class="inv-btn" onclick="exploreNextStage()">다음 단계 진행</button>
  <button class="inv-btn" onclick="if(confirm('탐험을 정말 중단합니까?')) { exploring=null; updateUser();log('이전 화면으로 돌아감'); }">탐험 중단</button>`;
  log(html);
}
function exploreNextStage() {
  if (!exploring || exploring.done) return;
  if (user.hp <= 1) { // HP 1 이하: 자동 종료
    exploring.done = true;
    showExploreProgress();
    return;
  }
  let stage = exploring.stage;
  // 이벤트 종류 결정 (전투/보상/휴식)
  let roll = Math.random();
  let eType = "battle";
  if (roll < 0.16) eType = "reward";
  else if (roll < 0.25) eType = "rest";
  else if (roll > 0.92) eType = "elite";
  // 난이도 보정
  let diff = exploring.diff;
  let desc = "";
  if (eType === "battle") desc = "일반 몬스터와 전투!";
  if (eType === "elite") desc = "<span class='unique-monster'>엘리트 몬스터와 전투!</span>";
  if (eType === "reward") desc = "<span style='color:#bbeeff'>보물 발견! 추가 보상!</span>";
  if (eType === "rest") desc = "<span style='color:#8aff8a'>안전한 장소 발견! 휴식 가능</span>";
  // 전투/이벤트 버튼
  let nextBtn = `<button class="inv-btn" onclick="resolveExploreEvent('${eType}')">이벤트 진행</button>`;
  log(`<b>[탐험 - ${exploring.zone}]</b><br>스테이지 ${stage} / ${exploring.maxStage}<br>${desc}<br>${nextBtn}`);
}
function resolveExploreEvent(eType) {
  let diff = exploring.diff;
  // 난이도 배율: 쉬움 0.7, 보통 1.0, 어려움 1.2, 매우어려움 1.35
  let diffMap = { "쉬움":0.7, "보통":1.0, "어려움":1.2, "매우어려움":1.35 };
  let diffBonus = diffMap[diff] || 1.0;
if (eType === "battle" || eType === "elite") {
  exploringStageSource = (eType === "battle" ? "hunt" : "dungeon");
  let oldMakeMonster = window.makeMonster;
  // diff는 exploring.diff로부터 받은 난이도 문자열 (ex: "쉬움", "지옥" 등)
  let diffBonus = diffMap[diff] || 1.0;
  window.makeMonster = function(level, isDungeon = false) {
    let m = oldMakeMonster(level, isDungeon);
    m.hp = Math.round(m.hp * diffBonus);
    m.atk = Math.round(m.atk * diffBonus);
    m.def = Math.round(m.def * diffBonus);
    return m;
  };
    let gold0 = user.gold, exp0 = user.exp, stones0 = user.stones, inv0 = user.inv.length;
     battle("explore", diff);
 setTimeout(() => {
      window.makeMonster = oldMakeMonster;
      // *** 보상 후 [다음] 버튼 삽입 ***
      let goldGet = user.gold - gold0;
      let expGet = user.exp - exp0;
      let stoneGet = (user.stones||0) - (stones0||0);
      let itemGet = Math.max(0, user.inv.length - inv0);
      exploring.rewardSum.gold += Math.max(0,goldGet);
      exploring.rewardSum.exp += Math.max(0,expGet);
      exploring.rewardSum.stones += Math.max(0,stoneGet);
      exploring.rewardSum.item += itemGet;

      // [다음] 버튼으로만 탐험 진행
      let btn = `<br><button class="inv-btn" onclick="afterExploreEvent()">다음</button>`;
      let lastLog = document.getElementById("logbox").innerHTML;
      document.getElementById("logbox").innerHTML = lastLog + btn;
    }, 300);
    return;
  }

  if (eType === "reward") {
    // 난이도별 추가 보상
    let gold = Math.round(rint(40,90) * diffBonus);
    let stones = rint(0,1+Math.floor(diffBonus*3));
    let exp = Math.round(rint(15,40) * diffBonus);
    user.gold += gold; user.stones = (user.stones||0) + stones; user.exp += exp;
    exploring.rewardSum.gold += gold;
    exploring.rewardSum.stones += stones;
    exploring.rewardSum.exp += exp;
    log(`<span style="color:#bbeeff">[보물 발견] GOLD+${gold}, 강화석+${stones}, EXP+${exp}</span><br>
    <button class="inv-btn" onclick="afterExploreEvent()">다음</button>`);
    return;
  }
  if (eType === "rest") {
    let heal = Math.round(user.maxhp * 0.24 + rint(2,10));
    user.hp = Math.min(user.maxhp, user.hp + heal);
    log(`<span style="color:#8aff8a">[휴식 성공] HP +${heal} 회복!</span><br>
    <button class="inv-btn" onclick="afterExploreEvent()">다음</button>`);
    return;
  }
}
function afterExploreEvent() {
  exploring.stage++;
  showExploreProgress();
}
// 환생: 장비 착용/창고만 유지, 소지품 초기화
function rebirth(){
  if(user.level<999){log("레벨 999 달성 시에만 환생 가능!<br><button class='inv-btn' onclick='showTown()'>돌아가기</button>");return;}
  if(!confirm("환생 시 레벨/스탯/소지품/골드가 초기화됩니다. 착용장비와 창고는 유지됩니다. 진행할까요?")) return;
  let keepEquip = {};
  for(let slot of equipSlots) if(user.equip[slot]) keepEquip[slot] = user.equip[slot];
  let keepStorage = user.storage||[];
  user.rebirth = (user.rebirth||0) + 1;  // 먼저 증가시킴!
  user.level=1; user.exp=0; user.gold=100;
  user.stats = [1,1,1,1,1].map(x => x + user.rebirth * 10); // 환생 누적!
  user.statmax=9999; user.hp=30; user.maxhp=30;
  user.equip=keepEquip; user.inv=[]; user.stones=0; user.storage = keepStorage;
  log("환생 완료! 기본 능력치 +10이 부여되었습니다.<br><button class='inv-btn' onclick='showTown()'>돌아가기</button>");
  updateUser();
}
</script>
</body>
</html>
